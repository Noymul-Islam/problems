
#include<stdio.h> #include<string.h> #include<iostream> #include<algorithm> #include<vector> using namespace std; struct road { int x,y,w; }; int par[10050]; int visit[10050]; vector<road>weight; bool comp(road p, road q) { return p.w < q.w; } int find_representor(int x) { int r; if(par[x]==x) return x; return par[x]=find_representor(par[x]); } void mst(int a,int node) { int i,u,v,r1,r2,cost=0,sub=0,vol,node1; vol=weight.size(); sub=node; for(i=0;i<vol;++i) { r1=find_representor(weight[i].x); r2=find_representor(weight[i].y); if(r1!=r2&&weight[i].w<a) { par[r2]=r1; cost+=weight[i].w; --sub; } } printf("%d %d\n",cost+(a*sub),sub); return ; } int main() { int i,j,t,x,y,n,m,a,cost,node; road u; scanf("%d",&t); for(i=1;i<=t;++i) { scanf("%d %d %d",&n,&m,&a); memset(par,0,sizeof(par)); memset(visit,0,sizeof(visit)); node=0; for(j=1;j<=m;++j) { scanf("%d %d %d",&u.x,&u.y,&u.w); weight.push_back(u); par[u.x]=u.x; par[u.y]=u.y; if(visit[u.x]!=1) ++node; if(visit[u.y]!=1) ++node; visit[u.x]=1; visit[u.y]=1; } sort(weight.begin(),weight.end(),comp); printf("Case #%d: ",i); mst(a,n); weight.clear(); } return 0; }


